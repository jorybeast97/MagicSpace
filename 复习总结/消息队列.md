

## RabbitMQ

>  RabbitMQ是一种基于AMQP协议是使用Erlang开发的消息队列,对消息的路由,持久化,负载均衡等内容有着良好的支持。

### RabbitMQ重要概念

#### Exchange

交换机作用是通过某个规则将消息路由到某个队列。发送端不会把消息发送到队列中,而是将消息先发送给交换机,交换机根据路由键的规则再路由到指定的消息队列中。

#### Queue

FIFO的队列,用于暂时存储消息,并能够将消息发送给执行的消费者

#### Binding

将消息队列与一个交换机绑定,完成对消息的路由

### RabbitMQ三种路由方式

#### 简单队列

RabbitMQ中最简单的一种路由方式,一个或者多个消费者对同一个消费队列进行消费,可以使用公平方式或者轮询方式进行。

- 公平方式 : 根据应用处理消息的时间长度进行消费,能够提高消费者的利用率
- 轮询方式 : 对多个消费者进行轮询消息发送,保证每个消费者所处理的消息数量相同

![](https://s2.ax1x.com/2020/01/07/l6fkB6.png)

#### 订阅模式(Fanout Exchange)

一个生产者，多个消费者，每一个消费者都有自己的一个队列，生产者没有将消息直接发送到队列，而是发送到了交换机，每个队列绑定交换机，生产者发送的消息经过交换机，到达队列，实现一个消息被多个消费者获取的目的。需要注意的是，如果将消息发送到一个没有队列绑定的exchange上面，那么该消息将会丢失，这是因为在rabbitMQ中exchange不具备存储消息的能力，只有队列具备存储消息的能力。

![](https://s2.ax1x.com/2020/01/09/lWzo6J.png)

订阅模式常见于各种推文,根据不同的用户,维护其消息队列,将推文发送至消息队列进行读取。

#### 路由模式(Direct Exchange)

路由模式下,消息中会有一个`  key`,只有对应的key才能够发送到指定的消息队列。而无效的消息则会被丢弃

![](https://s2.ax1x.com/2020/01/09/lfEI5d.png)

#### 主题模式(Topic Exchange)

实际上主题模式是对于路由模式的进一步增强,路由模式只能指定某个消息进入某个队列,但如果希望某个消息按照某种规则进入多个队列,则需要使用主题模式,主题模式通过使用通配符来完成对于消息的匹配。能够更加灵活的完成对于消息的路由。

![](https://s2.ax1x.com/2020/01/09/lfmLWj.png)

### 消息确认机制

RabbitMQ提供了多种消息确认机制保证消息在发送的过程中能够可靠送达,其不同的级别对吞吐量有也不同的影响。

消息确认机制从`  生产者——队列`、`  队列——消费者`两个方面进行了保障。

#### 消息生产者确认机制

当一个消息在系统中产生并路由到消息队列时,整个过程要经历`  网络->网卡->总线->操作系统->应用程序`等多个过程,不能够保证每一个过程都是理想状态,在这种情况下,如果产生了消息丢失,就需要对其进行处理,因此RabbitMQ提供了以下几种在生产者和队列之间交互的消息确认机制。

- 事务机制 : 在channel中的`  tx.Select()` , `  tx.Commit()`,`  tx.Rollback`等方法分别对应开启事务,提交事务,回滚操作。但是事务机制会让生产者和队列产生过多的交互(不断发送ACK来确认消息到达),造成资源浪费,同时事务机制也是阻塞的,发送一条消息后需要等到确认此能够发送下一条,实际使用较少。
- 批量处理 : 当生产者发送一定数量消息后,队列会发送一个ACK。这样的好处是能够提高确认效率，一次确认多条消息。但是如果返回了`  NACK`，则 需要将这一批的所有消息重新发送,在网络状态差的环境下,可能会导致性能更差。
- 异步处理 : 以异步的方式进行消息确认,当生产者发送一条消息后,不会进行阻塞,会由另一个线程来完成确认工作,是一种常用的消息确认方式,能够保证实现确认机制并且不会阻塞当前生产者的消息发送。

#### 消费者确认机制

当队列中的消息发送给消费者后,如果消息在网络中丢失,同时在队列中被删除,除非将持久化文件读取进队列,否则无法找回,因此提供了消费者和队列间的消息确认机制。

- 自动确认(`  AutoAsk : true`) : 自动确认机制是一种"即发即忘"的机制,在消息队列将消息发送给消费者后,就将消息从队列中删除,是一种不够安全的行为,但是能够提高系统的吞吐量。
- 手动确认(`AutoAsk : false ` ) : 手动确认是当消息完成发送后,会等待消费者返回消息的`  TargId`作为成功接收的凭证,如果由于信道延迟等原因造成消息丢失,会让消费队列重新发送信息。如果队列配有多个消费者,当一个消息发送失败后,队列会轮询发送给其他的队列。

### 消息重复及解决方法

#### 消息重复

造成消息重复的根本原因在于**网络不可达**，这个原因无法根本解除,所以处理消息重复的解决办法就变成了,如果出现了消息重复,如何去除消息重复对于系统的影响。

#### 消费端处理业务幂等性操作

当消息重复后,只要消息处理的业务具有幂等性,我们就不需要对重复的消息进行处理。

例如在数据库中`  insert`一条记录,即使消息重复,因为有同样的ID，数据也不会成功插入,同理删除一条数据一样,但是往往幂等的操作可能在一些问题上无法解决,例如更新数据,如果在两次重复的消息中,数据发生了变化,再次执行重复消息可能导致出现脏数据。

由于RabbitMQ并未对消息重复做任何处理,所以需要开发者从消费者和生产者两方面进行预防。

#### 消费者处理

由于AMQP定义了消息确认机制,而消息确认机制是指`  消息至少被一次交付`所以可能出现消息重复,例如当消息在网络中延迟时间超过限制,队列重新发送,然后之前的延迟消息又正常到达了消费者,则出现了两个一样的消息。

针对这种情况,可以使用全局ID来处理,在生产者方面,为每一个消息添加一个全局的ID，在消费者方面维护一个Map,每当接收一个消息时,将消息的全局ID存入Map，并将使用位置为`  IsUsed`，每次出现新的消息都检查Map,如果该消息在Map中存在并且已经被使用过,则将其丢弃,视为重复消息。

#### 生产者处理

由于RabbitMQ为了防止消息丢失,实现了两种生产者消息确认机制AMQP事务和confirm确认。

在AMQP事务中,整个过程阻塞完成,如果失败重新发送，所以不会存在产生重复消息的可能性，但是由于事务需要频繁与broker进行交互,导致整个队列性能低下,一般很少使用事务处理。

而在confirm中则会导致出现重复的消息,由于confirm中使用的时ACK，所以同样可能因为网络的不可达导致消息重复。

- 单体重复 : 当`  Ack`返回时,出现了网络延迟,生产者未收到应答，认为消息未发送成功,又重新发送了一条消息,此时出现了消息重复。
- 多条重复 : 当使用批量确认时,可能某一条消息丢失,返回了`  Nack`，而生产者需要将这一批的数据全部重新发送，此时可能导致多条消息重复。

解决方式相同,使用消息状态处理,用全局Id来表示一个消息,如果消息被执行,则更新数据,再次出现该消息时,认为出现重复消息,进行丢弃。

### 死信队列与延时队列

#### 死信队列

当一个消息发生了以下几种情况后,称之为死信。

1. 消息被拒绝并设置requeue参数未false
2. 消息过期
3. 队列达到最大长度

当产生一个死信后,如果所在的队列配置有`  x-dead-letter-exchange`参数时,会把该死信发送到对应的**死信交换器**然后路由到与其绑定的队列,而这个队列就称之为死信队列。

在消息队列中可以通个`  x-message-ttl`来设置所有的消息的过期时间,也可以对单个消息的`  expiration`设置过期时间。

#### 延时队列

在RabbitMQ中， 不存在延时队列的概念,但是可以用死信队列来模拟延时队列。消费者来监听死信队列而非消息队列。

![](https://s1.ax1x.com/2020/03/30/GmV1yR.png)

真实进行消费的时死信队列,而消费队列主要是对消息进行延时操作。

