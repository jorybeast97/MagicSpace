## AOP模型

AOP面向切面编程是一种对于OOP面向对象编程的补充很完善。面向对象代码执行过程中，有很多重复的工作可以由AOP进行抽取，从切面层完成对这些功能的增强，例如日志处理，拦截，监听等功能。由于OOP是纵向进行，可以使用AOP将其中重复的内容进行抽取编写，完成对代码简化，同时能够解耦。

### AspectJ

aspectJ使用的是静态代理技术，需要在编译期间就完成对于代理类的创建,并让代理类和本类继承同一个接口,在代理类内部维护一个本类对象。

### JDK动态代理

JDK动态代理要求被代理的类需要实现至少一个接口。JDK动态代理会通过反射创建一个代理类，该类实现了InvocationHandler，并重写invoke方法，能够将原代理类的参数，方法以Class[]形式传递，同时由Proxy通过newInstance创建代理类，这个代理类同样实现了相同的接口，使用该代理类即可完成相应的方法。

具体增强原理在于，当调用切点方法时，会生成一个代理类，同时将这个这个方法请求被invocationHandler拦截，方法参数以及相关信息被以反射的形式传送给新的代理对象，同时根据切面完成对代理类方法的增强，完成后将结果回调给原有的方法。

### CGLib动态代理

CGLib动态的代理通过集成目标类来完成，通过重写父类方法完成对于目标类方法的增强，由于是继承方式，所以不能够对final类进行增强。

## Spring如何解决循环依赖

> 可以将这部分内容添加到IOC容器中，显示逼格

如果对象A内部依赖对象B，对象B依赖对象A，或者多个对象互相依赖构建成了一个循环。在这种情况下，会导致Spring一直在创建对象过程，和死锁相同，只要破解一环就可以完成。

Spring使用了**三级缓存**，在IOC容器中，bean的储存实际上存储在三层缓存中 : 

- singletonObjects : 一般bean存储位置
- earlySingletonObjects : 提前曝光对象缓存
- singletonFactories : 单例工厂

在出现对象A中依赖对象B时，首先会检查singletonObjects，如果内部有，则将这个Bean注入依赖B，如果没有再去曝光对象缓存中寻找，如果有则引用，如果没有则继续向上，当到达单例工厂时，会创建一个对象A，但是此时A是不完美的，参数等内容都是默认值，正常情况下，这个"不完美的"bean应该是不能够被使用的，所以它不会放在第一层缓存，而是放在可曝光缓存，将自己暴露给需要依赖的对象，当B再创建时，B会在第二层发现这个不完美的A，然后将其注入自己，注入后，此时B是完美的，当使用B时会再次检查A，然后A会把B注入到自己种，这时循环依赖就完成相互注入。

整个过程实际上就是首先让一个曝光自己，虽然此时的对象不够完整，但是已经能够被其他对象依赖注入，相当于破环的过程，在之后使用时，就会再将"不完整的"A进行在注入。

## AOP底层原理ASM

> ASM是一个Java字节码操控框架，能够用来动态生成类或者增强类的功能，ASM可以直接生成二进制class文件，可以在类被加载进入虚拟机之前改变类的行为。例如CGLib就是用了ASM

字节码增强 : 在Class文件中添加某些代码













