## TCP协议

### 简述

> **TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。**

- 面向连接型的传输协议：每一次完整的数据传输都要经过建立连接、使用连接、终止连接的过程；

- 可靠、出错重传、且每收到一个数据都要给出相应的确认，保证数据传输的可靠性；

- TCP连接是基于字节流的，而非报文；传输单位为数据段，每次发送的TCP数据段大小和数据段数都是可变的；

- 仅支持单播传输，支持全双工传输。

### 三次握手

首先来假设一个场景，你的妈妈给你介绍了一个女孩，你们要一起吃饭，此前你们从来没有见过面。

**第一次挥手**

掏出手机，给女孩发了一条信息 : 

> 你好 , 我们中午一起吃个饭吧 ?

如果女孩很久没有回答你的消息，你就可以确认她没有看到，此时你就可以自己去吃饭了。

如果她应答了消息，则可以视为第一次握手成功。

**第二次握手**

虽然她回应了消息，但是她可能随便回了一句"哦"，"天气不错"等和吃饭无关的内容，此时可以看做沟通失败，因为她没有对你的消息作出正确的应答。

如果她回答了"在餐厅见"。那么第二次握手可视作成功。

**第三次握手**

在收到消息后，你忽然接到一个电话，BOSS叫你去开会议，十分紧急，所以你没有给女孩回复，或者回复了"抱歉，暂时有事去不了"，此时可以视作第三次握手失败。

如果你回复了"OK ，我马上就赶到"。那么第三次握手成功，TCP数据将被发送。

----------------------------

如果想让两个人之间有效沟通，以上的三次对话是必须的，可以归结为以下 : 

> **为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。**

如果把女孩作为客户端，我们作为服务端，可以说 ： 

第一次和第二次握手为了让服务端听懂客户端的请求，第二次和第三次握手为了让客户端听懂服务端的请求。

**为什么是三次而非两次 ? **

>  **第三次握手主要为了防止已经失效的报文请求突然传送而产生的错误。**

在程序中，如果我们一个消息传送失败，一般来说都会再次进行发送，TCP依旧如此。假如现在A向B传输一段报文，但是由于网络等原因问题，B在规定时间内没有回复，此时A就认为该段报文传送失败了，再次向B发送，传输成功后关闭了链接。

但是实际第一段报文并没有丢失，只是由于特殊原因在网络中被滞留了，当第二段报文传输完成并关闭了TCP连接时，第一段报文却到达了B。

假如没有第三次握手的流程，则B会认为A又向自己发送了一条报文，自己应当确认并建立与A的连接，这样就会出现问题。而如果有了第三次握手，由于A并没有建立连接的需求，虽然B收到了过期报文并对A发出建立连接的请求，但是A会无视这个请求，保证了数据的准确性。

> 在Google  Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值.  所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的. 请注意这里的本质需求,信道不可靠,  数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的,  即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息,  那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。

**特殊值变化**

![](https://s2.ax1x.com/2020/01/17/1SmGNV.jpg)

![](https://s2.ax1x.com/2020/01/17/1SmrAx.png)

### 四次挥手

Client作为主动发起端，Server作为被动关闭端。

**第一步，**Client主动发起一个Req给Server，里面包含FIN标识位=1，CLient的Seq序列号N，表示的是当前Client在该连接上的当前序列号。

**第二步，**Server端在收到这个含有FIN的Req消息之后，校验无误之后会立马回复ACK消息给CLient端，消息内部包含ACK标志位为1，同时Seq号码是FIN的请求消息的Seq号+1。此时的Sever同时会主动发个结束标识给Server上面的应用层程序，应用层程序可以决定是立马结束，还是等到服务其上面的该连接中的数据处理完了之后，在发送FIN消息给Client来关掉另外的一半连接。

**第三步，**Server端在处理完该连接上面的Pending住的数据之后，应用程序会close这个连接。Client会主动发起FIN的Req消息给Client端。消息内部带有，FIN=1的结束符标识位，以及Server端的Seq序列号。

**第四步，**Client端在收到对应的FIN消息之后，会主动通知应用层程序，告知这个连接现在需要关闭了。然后，Client会回复ACK消息给Server，以便断开另外一个方向的通道，这个消息包含ACK=1的标识位和FIN的REQ带过来的Seq+1。

**原因**

因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。

如果是三次挥手，会怎么样？三次的话，被动关闭端在收到FIN消息之后，需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，那么这样的三次挥手就不能满足条件。

## UDP协议

> UDP套接口是无连接的、不可靠的数据报协议

UDP的数据包同样分为头部(header)和数据(payload)两部分。UDP是传输层(transport layer)协议，这意味着UDP的数据包需要经过IP协议的封装(encapsulation)，然后通过IP协议到目的电脑。随后UDP包在目的电脑拆封，并将信息送到相应端口的缓存中。

UDP不可靠原因 : 

**UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。**

所以UDP协议不可靠归结为以下几方面 : 

- 不保证消息交付：不确认，不重传，无超时
- 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞
- 不跟踪连接状态： 不必建立连接或重启状态机
- 不需要拥塞控制： 不内置客户端或网络反馈机制

